<div class="lift:surround?with=navigable;at=content">

<h2>Elements</h2>



<h3><code>RElem</code></h3>
<p>Often you can use events and properties on their own, since they are
<code>NodeSeq=&gt;NodeSeq</code> or <code>Elem=&gt;Elem</code> functions.
There also exists the trait <code>RElem</code>, which you can use directly
or via classes and traits that extend it.
<code>RElem</code> contains a base <code>scala.xml.Elem</code>, a
unique id, a set of <code>DomEventSource</code>s and <code>DomProperty</code>s,
and a set of <code>Page</code>s it has been rendered to. When you call <code>render</code>
on an <code>RElem</code>, which returns an <code>Elem</code>, it finds the current <code>Page</code> via the
implicits scope (if you don't pass one in explicitly), records it, and
adds it to all <code>DomProperty</code>s. Then, a <code>scala.xml.Elem</code>
is returned, which is generated by starting with <code>baseElem</code>,
adding the id attribute, adding attributes that correspond to the
current values of the properties, and adding event handler attributes
for those <code>DomEventSource</code>s to which listeners have been
added.</p>
<p><code>RElem</code> extends <code>net.liftweb.util.Bindable</code>,
so you can use instances directly in bind expressions (both using <code>Helpers.bind</code>,
and using CSS Selector binding), without calling <code>render</code>.
Lift will call the <code>asHtml</code> method, which calls <code>render</code>
with the <code>Page</code> that is in the <code>CurrentPage</code> <code>RequestVar</code>
(you don't have to set it; the first time in a request its value is
read, a new <code>Page</code> will be created, which will be kept for
the rest of the request).</p>
<p>There are a number of ways to get <code>RElem</code> instances.
Of course, you can extend it yourself. There are many traits, classes,
and factories for HTML elements, such as form elements. There's a
general-purpose factory, <code>RElem.apply(parentElem:
scala.xml.Elem, children: RElem*)</code>, which wraps a regular <code>scala.xml.Elem</code>
(and optionally some <code>RElems</code> to put inside), and its
overload, <code>RElem.apply(text: String)</code>, which returns an <code>RElem</code>
that wraps a &lt;span&gt; containing the text. And there's <code>Cell</code>
and <code>Repeater</code>.</p>

<h3><a name="Cell"><code>Cell</code></a></h3>
<p>If you want the contents of an element to be dynamic, you
may want to use <code>Cell</code>. <code>Cell</code> is a trait that extends <code>RElem</code>. It
is used to manage an <code>RElem</code> whose contents &mdash; its child
elements &mdash; are represented by a <code>Signal[NodeSeq]</code>. It
is available through implementations that extend it. But it also has a
factory that can be used in CSS selector binding, to make the contents
of any element &mdash; even one defined in a template &mdash; dynamic.</p>

<p>This factory actually takes and returns a <code>NodeSeq=&gt;NodeSeq</code>.
When the returned function is called, it instantiates an <code>RElem</code>,
using the (template) <code>NodeSeq</code> passed to it as the outer
element. Its children are generated by running the binding function
passed in on the children of the template element.</p>

<a class="btn btn-primary" target="_blank" href="/showdemo/CellDemo">Live Example</a>

<h3><a name="Repeater"><code>Repeater</code></a></h3>
<p><code>Repeater</code> is the <code>SeqSignal</code> counterpart
of <code>Cell</code>. Where <code>Cell</code> defines its entire
contents using a <code>Signal</code> &mdash; whenever the <code>Signal</code>'s
value changes, the entire contents of the element have to be replaced
&mdash; <code>Repeater</code> uses a <code>SeqSignal[NodeSeq]</code>.
This is a very powerful feature. It means you can represent a dynamic
set of items, completely declaratively, and (without you worrying about
the details) when items change, only what needs updating will be
updated.</p>
<p>Besides for implementations such as <code>Select</code> (for HTML
select elements), <code>Repeater</code> has a factory similar to <code>Cell</code>'s.</p>
<p>Once again, you pass the factory a binding function to be run on
the children of the template element, and it returns a binding function
that lift runs against the template. When run, the function instantiates
an <code>RElem</code> that uses the element from the template as the
outer element, and the binding function you passed to the factory is run
on each element.</p>

<a class="btn btn-primary" target="_blank" href="/showdemo/RepeaterDemo">Live Example</a>

</div>
